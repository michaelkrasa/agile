=========================================
Answers for COMP26120 Lab Exercise 1
Name:
=========================================

Pick one problem from each problem set and for each problem produce two different algorithms.
For each algorithm produce (1) psuedocode, (2) a correctness explanation, and (3) a complexity
analysis. The second algorithm should be 'better' than the first.

See COMPjudge for the full instructions.

=========================================
Problem Set 1
Chosen Problem is A

===================
Algorithm 1
------------
1) Pseudocode

fixedPoint(array,n)

found = false
position = 0

for (i=0; i < n; i++)
	if (i = a[i])
		position = i
		found = true
		break

if(found)
	return position
else
	print("No")


------------
2) Correctness Explanation

The algorithm goes through the array one by one and checks if by any chance the
number at position I is the same as the number of the position. If yes then it
immediately returns I, if not the for loop finishes and outputs "No"

------------
3) Worst Case Complexity Analysis

The dominant basic operation is checking whether i is the same as a[i] in every
iteration of the for loop, which is dependent on the length of the array.
Worst case scenario is n comparisons for an array of length n.


===================
Algorithm 2
------------
1) Pseudocode

binarysearch(array,n)

L = 0
R = n-1

while (L<=R)
	pos = (L+R)/2
	if (array[pos] < pos)
        L = pos + 1
    else if (array[pos] > pos)
        R = pos - 1
    else
        return pos;

return "No"


------------
2) Correctness Explanation

The algorithm goes to the middle of the array, and checks if the int at the
position is either larger or smaller than its index. Since the array is ordered,
depending on the result it knows whether to jump to the right or left to get
closer to the desired number. When the algorithm fails to find such number
(it doesn't exist), L or R reaches over the other one and the initial condition
of the while loop will not be satisfied and the algorithm will end.
------------
3) Worst Case Complexity Analysis

The worst case scenario will be reached when the element is not found in the array
meaning that the algorithm will have to do log2(n) comparisons to go all the way to
either side of the array. e.g. array with 8 ints in it => 2^3 = 8 => there only have
to be three comparisons until the algorithm ends. 


=========================================
Problem Set 2
Chosen Problem is G
===================
Algorithm 1
------------
1) Pseudocode

minNumberOfCoins(int T)
  noOfCoins = 0;
  numberSoFar = 0;
  desiredNumber = T;

  for(int p=0; p*200 <= desiredNumber; p++)
    for(int o=0; o*100 < 200; o++)
      for(int n=0; n*50 < 100; n++)
        for(int m=0;m*20 < 50; m++)
          for(int l=0;l*10 < 20; l++)
            for(int k=0;k*5 < 10; k++)
              for(int j=0;j*2 < 5; j++)
                for(int i=0; i < 2; i++)
                  if(i*1 + j*2 + k*5 + l*10 + m*20 + n*50 + o*100 + p*200 == desiredNumber)
                  {
                    noOfCoins = i+j+k+l+m+n+o+p
                    break
                  }
                
  print(noOfCoins);

------------
2) Correctness Explanation

To find the minimum number of coins used this algorithm goes through every possible combination.
To achieve this while keeping the number of coins to a minimum we have to precisely control
when each for loop is complete to jump onto the next one by setting the maximum limit as shown.
To check whether we're at the right combination we have to have an if statement combining the number
of times each of the loops have iterated and the value of the coins they're representing. If
the numbers are the same, the algorithm adds up the number of times all the loops have iterated
to get the final number.

------------
3) Worst Case Complexity Analysis

In the worst case scenario you're dealing with 8 nested for loops and making a comparison every single 
time until it finds the right combination. We're dealing with 2^9 comparisons when T is larger than or 
equal to 200 which means its roughly twice the size of T. With larger numbers, the 8 loops have to be 
done every time we want to iterate the outer loop (2^8).

==================
Algorithm 2
------------
1) Pseudocode

minNumberOfCoins(int T)

noOfCoins = 0;
numberSoFar = 0;
desiredNumber = T;

while(numberSoFar < desiredNumber)
	if (desiredNumber - numberSoFar >= 200)
		numberSoFar += 200
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 100)
		numberSoFar += 100
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 50)
		numberSoFar += 50
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 20)
		numberSoFar += 20
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 10)
		numberSoFar += 10
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 5)
		numberSoFar += 5
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 2)
		numberSoFar += 2
		noOfCoins++

	else if (desiredNumber - numberSoFar >= 1)
		numberSoFar += 1
		noOfCoins++

print(noOfCoins)

------------
2) Correctness Explanation

Its a very simple and systematic approach to this problem, if the difference
between our number and our desired number is in some of our set coin values,
the number is increased by the corresponding coin value. It is making an
optimal choice at each stage.


------------
3) Worst Case Complexity Analysis

There isn't really a worst case scenario is an extremely large number since
our largest coin is only 200 so that while loop will iterate many times.
In terms of n, the complexity depends on the divisibility of all possible
coin values and since the while loop is structured top down it will always
reach a statement very efficiently.
